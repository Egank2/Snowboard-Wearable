# -*- coding: utf-8 -*-
"""Snowboard Wearable(1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YwvdjgjnogNCRHiKY-ZPJMXoI5pTnrre
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.interpolate import make_smoothing_spline

df = pd.read_csv(
    "runs/run9.csv",
    header=None,
    names=["timestamp", "quat_w", "quat_x", "quat_y", "quat_z", "lat", "lon", "gps_speed", "altitude"]
)

# 1.1) Convert Quaternion to Euler Angles (roll, pitch, yaw)
def quaternion_to_euler(w, x, y, z):
    """
    Convert a quaternion (w, x, y, z) to Euler angles (roll, pitch, yaw).
    All angles are in radians.
    """
    roll = np.arctan2(2*(w*x + y*z), 1 - 2*(x*x + y*y))
    pitch = np.arcsin(2*(w*y - z*x))
    yaw = np.arctan2(2*(w*z + x*y), 1 - 2*(y*y + z*z))
    return roll, pitch, yaw

roll_list = []
yaw_list = []
for idx, row in df.iterrows():
    r, p, y = quaternion_to_euler(row['quat_w'], row['quat_x'], row['quat_y'], row['quat_z'])
    roll_list.append(r)
    yaw_list.append(y)

def moving_average(data, window):
    result = []
    for i in range(len(data)):
        box = data[max(0, i - window):min(len(data), i + 1)]
        box_avg = np.sum(box) / len(box)
        result.append(box_avg)
    
    return result

# yaw_list = (yaw_list + (200 * np.pi / 180) + np.pi) % (2 * np.pi) - np.pi 
yaw_list = [(y + (200 * np.pi / 180) + np.pi) % (2 * np.pi) - np.pi for y in yaw_list]

roll_list_smooth = moving_average(roll_list, 100)
yaw_list_smooth = moving_average(yaw_list, 100)

df["gyro_roll"] = roll_list_smooth
df["gyro_yaw"] = yaw_list_smooth

# 2) ACTION DETECTION

def detect_action_imu(roll_data, yaw_data, imu_threshold=0.5, window_size=5):
    action_labels = []
    half_win = window_size // 2
    roll_pad = np.pad(roll_data, (half_win, half_win), mode='edge')
    yaw_pad  = np.pad(yaw_data, (half_win, half_win), mode='edge')
    for i in range(len(roll_data)):
        r_segment = roll_pad[i : i + window_size]
        y_segment = yaw_pad[i : i + window_size]
        avg_gyro = np.mean(np.abs(r_segment)) + np.mean(np.abs(y_segment))
        action_labels.append("active" if avg_gyro > imu_threshold else "inactive")
    return action_labels

def detect_action_gps(gps_data, speed_threshold=0.5, window_size=5):
    action_labels = []
    half_win = window_size // 2
    gps_pad = np.pad(gps_data, (half_win, half_win), mode='edge')
    for i in range(len(gps_data)):
        seg = gps_pad[i : i + window_size]
        action_labels.append("active" if np.mean(seg) > speed_threshold else "inactive")
    return action_labels

# 3) PEAK DETECTION (Algorithm 1)

def detectPeaks(x, delta, band):
    max_peaks = []
    min_peaks = []
    max_val = -np.inf
    min_val =  np.inf

    for i in range(len(x)):
        val = x[i]
        if val > max_val:
            max_val = val
        if val < min_val:
            min_val = val
        
        if val < max_val - delta:
            max_peaks.append(i)
            max_val = val
        elif val > min_val + delta:
            min_peaks.append(i)
            min_val = val
        
    for i in range(len(max_peaks)):
        val = x[i]
        if abs(val) < band:
            del max_peaks[i]

    for i in range(len(min_peaks)):
        val = x[i]
        if abs(val) < band:
            del min_peaks[i]
    
    return max_peaks, min_peaks

# 4) TURN DETECTION (Algorithm 2)

def detectTurns(roll_data, yaw_data, delta=0.2, band=0.0, stance="regular"):
    # Lowering delta from 0.5 to 0.2 for increased sensitivity.
    roll_max, roll_min = detectPeaks(roll_data, delta, band)
    yaw_max,  yaw_min  = detectPeaks(yaw_data, delta, band)
    roll_peaks_all = [(idx, 'roll', 'max') for idx in roll_max] + [(idx, 'roll', 'min') for idx in roll_min]
    yaw_peaks_all  = [(idx, 'yaw', 'max') for idx in yaw_max] + [(idx, 'yaw', 'min') for idx in yaw_min]
    roll_peaks_all.sort(key=lambda x: x[0])
    yaw_peaks_all.sort(key=lambda x: x[0])

    turns = []
    for r_idx, r_axis, r_type in roll_peaks_all:
        best_y = None
        best_dist = float('inf')
        for y_idx, y_axis, y_type in yaw_peaks_all:
            dist = abs(y_idx - r_idx)
            if dist < best_dist:
                best_dist = dist
                best_y = (y_idx, y_axis, y_type)
        if best_y is None:
            continue
        y_idx, y_axis, y_type = best_y
        if r_type == 'min' and y_type == 'max':
            turn_label = "NO_FS" if stance == "regular" else "NO_BS"
        elif r_type == 'max' and y_type == 'min':
            turn_label = "NO_BS" if stance == "regular" else "NO_FS"
        elif r_type == 'min' and y_type == 'min':
            turn_label = "SW_FS" if stance == "regular" else "SW_BS"
        elif r_type == 'max' and y_type == 'max':
            turn_label = "SW_BS" if stance == "regular" else "SW_FS"
        else:
            continue
        turns.append({"time_index": r_idx, "turn_label": turn_label})
    turns.sort(key=lambda x: x["time_index"])
    return turns

# 5) EDGE & DIRECTION DETECTION

def infer_edge_direction(turns, stance="regular"):
    segments = []
    if not turns:
        return segments

    def parse_turn_label(lbl):
        normal_or_switch = "normal" if lbl.startswith("NO") else "switch"
        fs_or_bs = "frontside" if lbl.endswith("FS") else "backside"
        return normal_or_switch, fs_or_bs

    for i, trn in enumerate(turns):
        t_label = trn["turn_label"]
        t_idx   = trn["time_index"]
        direction, fsbs = parse_turn_label(t_label)
        if i == 0:
            if t_label == "NO_FS":
                init_edge = "backside"
                init_dir  = "normal"
            elif t_label == "NO_BS":
                init_edge = "frontside"
                init_dir  = "normal"
            elif t_label == "SW_FS":
                init_edge = "backside"
                init_dir  = "switch"
            elif t_label == "SW_BS":
                init_edge = "frontside"
                init_dir  = "switch"
            segments.append({"start_idx": 0, "end_idx": t_idx, "edge": init_edge, "direction": init_dir})
        else:
            prev_turn = turns[i-1]
            p_label = prev_turn["turn_label"]
            p_normal_or_switch, p_fsbs = parse_turn_label(p_label)
            segments.append({"start_idx": prev_turn["time_index"], "end_idx": t_idx, "edge": p_fsbs, "direction": p_normal_or_switch})

    last_turn = turns[-1]
    lt_label  = last_turn["turn_label"]
    l_dir, l_fsbs = parse_turn_label(lt_label)
    segments.append({"start_idx": last_turn["time_index"], "end_idx": len(df) - 1, "edge": l_fsbs, "direction": l_dir})

    return segments

# 6) TECHNIQUE DETECTION (Algorithm 3)

def detectTechniques(turns, yaw_data, delta=0.1, band=0.0, cvs=.01):
    # Lowering delta from 0.2 to 0.1 for increased sensitivity.
    y_max, y_min = detectPeaks(yaw_data, delta, band)
    all_y_peaks = sorted(y_max + y_min)

    if len(turns) < 2:
        return []

    techniques = []
    for i in range(len(turns) - 1):
        t_i = turns[i]["time_index"]
        t_i1 = turns[i+1]["time_index"]
        n_peaks = sum(1 for p in all_y_peaks if t_i < p < t_i1)
        tau = (t_i1 - t_i)
        ratio = n_peaks / float(tau) if tau > 0 else 0
        techniques.append("skidding" if ratio > cvs else "carving")
    return techniques

# Get sensor data from df
roll_data = df["gyro_roll"].values
yaw_data  = df["gyro_yaw"].values
gps_data  = df["gps_speed"].values if "gps_speed" in df.columns else None

# Action detection using IMU data
action_labels_imu = detect_action_imu(roll_data, yaw_data, imu_threshold=0.5, window_size=5)
df["action_imu"] = action_labels_imu

if gps_data is not None:
    action_labels_gps = detect_action_gps(gps_data, speed_threshold=0.5, window_size=5)
    df["action_gps"] = action_labels_gps

# Turn detection using lowered thresholds
turns = detectTurns(roll_data, yaw_data, delta=0.2, band=0.0, stance="regular")

# Edge and direction detection per segment
segments = infer_edge_direction(turns, stance="regular")

# Technique detection with modified delta
techniques = detectTechniques(turns, yaw_data, delta=0.1, band=0.0, cvs=.035)

print("=== TOTAL TURNS DETECTED ===")
print(len(turns))

print("\n=== DETECTED TURNS (first 10 shown) ===")
for t in turns[:10]:
    print(t)

print("\n=== TECHNIQUE DETECTION (between consecutive turns) ===")
print("Techniques detected:", techniques)

roll_data_deg = roll_data * 180 / np.pi
yaw_data_deg = yaw_data * 180 / np.pi

plt.title("Gyro Roll and Yaw vs. Sample Index")


plt.plot(roll_data_deg, label="gyro_roll")
plt.plot(yaw_data_deg, label="gyro_yaw")
turn_indices = [t["time_index"] for t in turns]

# Plot turns
plt.scatter(turn_indices, yaw_data_deg[turn_indices], marker="o", color='red', label="Detected Turn", zorder=3)

# Plot techniques
techniques_colors = ['blue' if t == 'carving' else 'orange' for t in techniques]
plt.scatter(
    turn_indices[0:len(turn_indices) - 1], 
    [-100] * (len(turn_indices) - 1), 
    marker='^', 
    color=techniques_colors, 
    label='Technique (Blue: Carving, Orange: Skidding)', 
    s=100, 
    linewidths=1, 
    zorder=4
)

plt.xlabel("Sample Index")
plt.ylabel("Rotation (degrees)")
plt.legend()
plt.show()

